{"ast":null,"code":"import _regeneratorRuntime from \"/Users/savanasathre/CodingApril/youtube-react-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(fetchWatchDetails),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(fetchVideoDetails),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(watchWatchDetails);\n\nimport { fork, take, all, put, call } from 'redux-saga/effects';\nimport * as watchActions from '../actions/watch';\nimport { buildVideoDetailRequest, buildRelatedVideosRequest, buildChannelRequest, buildCommentThreadRequest } from '../api/youtube-api';\nimport { REQUEST } from '../actions';\nimport { SEARCH_LIST_RESPONSE, VIDEO_LIST_RESPONSE } from '../api/youtube-api-response-types';\nexport function fetchWatchDetails(videoId, channelId) {\n  var requests, responses;\n  return _regeneratorRuntime.wrap(function fetchWatchDetails$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        requests = [buildVideoDetailRequest.bind(null, videoId), buildRelatedVideosRequest.bind(null, videoId), buildCommentThreadRequest.bind(null, videoId)];\n\n        if (channelId) {\n          requests.push(buildChannelRequest.bind(null, channelId));\n        }\n\n        _context.prev = 2;\n        _context.next = 5;\n        return all(requests.map(fn => call(fn)));\n\n      case 5:\n        responses = _context.sent;\n        _context.next = 8;\n        return put(watchActions.details.success(responses, videoId));\n\n      case 8:\n        _context.next = 10;\n        return call(fetchVideoDetails, responses, channelId === null);\n\n      case 10:\n        _context.next = 16;\n        break;\n\n      case 12:\n        _context.prev = 12;\n        _context.t0 = _context[\"catch\"](2);\n        _context.next = 16;\n        return put(watchActions.details.failure(_context.t0));\n\n      case 16:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[2, 12]]);\n}\n\nfunction fetchVideoDetails(responses, shouldFetchChannelInfo) {\n  var searchListResponse, relatedVideoIds, requests, videoDetailResponse, videos;\n  return _regeneratorRuntime.wrap(function fetchVideoDetails$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        searchListResponse = responses.find(response => response.result.kind === SEARCH_LIST_RESPONSE);\n        relatedVideoIds = searchListResponse.result.items.map(relatedVideo => relatedVideo.id.videoId);\n        requests = relatedVideoIds.map(relatedVideoId => {\n          return buildVideoDetailRequest.bind(null, relatedVideoId);\n        });\n\n        if (shouldFetchChannelInfo) {\n          // we have to extract the video's channel id from the video details response\n          // so we can load additional channel information.\n          // this is only needed, when a user directly accesses .../watch?v=1234\n          // because then we only know the video id\n          videoDetailResponse = responses.find(response => response.result.kind === VIDEO_LIST_RESPONSE);\n          videos = videoDetailResponse.result.items;\n\n          if (videos && videos.length) {\n            requests.push(buildChannelRequest.bind(null, videos[0].snippet.channelId));\n          }\n        }\n\n        _context2.prev = 4;\n        _context2.next = 7;\n        return all(requests.map(fn => call(fn)));\n\n      case 7:\n        responses = _context2.sent;\n        _context2.next = 10;\n        return put(watchActions.videoDetails.success(responses));\n\n      case 10:\n        _context2.next = 16;\n        break;\n\n      case 12:\n        _context2.prev = 12;\n        _context2.t0 = _context2[\"catch\"](4);\n        _context2.next = 16;\n        return put(watchActions.videoDetails.failure(_context2.t0));\n\n      case 16:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _marked2, null, [[4, 12]]);\n}\n/******************************************************************************/\n\n/******************************* WATCHERS *************************************/\n\n/******************************************************************************/\n\n\nexport function watchWatchDetails() {\n  var _yield$take, videoId, channelId;\n\n  return _regeneratorRuntime.wrap(function watchWatchDetails$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        if (!true) {\n          _context3.next = 10;\n          break;\n        }\n\n        _context3.next = 3;\n        return take(watchActions.WATCH_DETAILS[REQUEST]);\n\n      case 3:\n        _yield$take = _context3.sent;\n        videoId = _yield$take.videoId;\n        channelId = _yield$take.channelId;\n        _context3.next = 8;\n        return fork(fetchWatchDetails, videoId, channelId);\n\n      case 8:\n        _context3.next = 0;\n        break;\n\n      case 10:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, _marked3);\n}","map":{"version":3,"sources":["/Users/savanasathre/CodingApril/youtube-react-master/src/store/sagas/watch.js"],"names":["fetchWatchDetails","fetchVideoDetails","watchWatchDetails","fork","take","all","put","call","watchActions","buildVideoDetailRequest","buildRelatedVideosRequest","buildChannelRequest","buildCommentThreadRequest","REQUEST","SEARCH_LIST_RESPONSE","VIDEO_LIST_RESPONSE","videoId","channelId","requests","bind","push","map","fn","responses","details","success","failure","shouldFetchChannelInfo","searchListResponse","find","response","result","kind","relatedVideoIds","items","relatedVideo","id","relatedVideoId","videoDetailResponse","videos","length","snippet","videoDetails","WATCH_DETAILS"],"mappings":";;oDAWiBA,iB;qDAoBPC,iB;qDAgCOC,iB;;AA/DjB,SAAQC,IAAR,EAAcC,IAAd,EAAoBC,GAApB,EAAyBC,GAAzB,EAA8BC,IAA9B,QAAyC,oBAAzC;AACA,OAAO,KAAKC,YAAZ,MAA8B,kBAA9B;AACA,SACEC,uBADF,EAEEC,yBAFF,EAGEC,mBAHF,EAIEC,yBAJF,QAKO,oBALP;AAMA,SAAQC,OAAR,QAAsB,YAAtB;AACA,SAAQC,oBAAR,EAA8BC,mBAA9B,QAAwD,mCAAxD;AAEA,OAAO,SAAUf,iBAAV,CAA4BgB,OAA5B,EAAqCC,SAArC;AAAA;AAAA;AAAA;AAAA;AACDC,QAAAA,QADC,GACU,CACbT,uBAAuB,CAACU,IAAxB,CAA6B,IAA7B,EAAmCH,OAAnC,CADa,EAEbN,yBAAyB,CAACS,IAA1B,CAA+B,IAA/B,EAAqCH,OAArC,CAFa,EAGbJ,yBAAyB,CAACO,IAA1B,CAA+B,IAA/B,EAAqCH,OAArC,CAHa,CADV;;AAOL,YAAIC,SAAJ,EAAe;AACbC,UAAAA,QAAQ,CAACE,IAAT,CAAcT,mBAAmB,CAACQ,IAApB,CAAyB,IAAzB,EAA+BF,SAA/B,CAAd;AACD;;AATI;AAAA;AAYe,eAAMZ,GAAG,CAACa,QAAQ,CAACG,GAAT,CAAaC,EAAE,IAAIf,IAAI,CAACe,EAAD,CAAvB,CAAD,CAAT;;AAZf;AAYGC,QAAAA,SAZH;AAAA;AAaH,eAAMjB,GAAG,CAACE,YAAY,CAACgB,OAAb,CAAqBC,OAArB,CAA6BF,SAA7B,EAAwCP,OAAxC,CAAD,CAAT;;AAbG;AAAA;AAcH,eAAMT,IAAI,CAAEN,iBAAF,EAAqBsB,SAArB,EAAgCN,SAAS,KAAK,IAA9C,CAAV;;AAdG;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAgBH,eAAMX,GAAG,CAACE,YAAY,CAACgB,OAAb,CAAqBE,OAArB,aAAD,CAAT;;AAhBG;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoBP,SAAUzB,iBAAV,CAA4BsB,SAA5B,EAAuCI,sBAAvC;AAAA;AAAA;AAAA;AAAA;AACQC,QAAAA,kBADR,GAC6BL,SAAS,CAACM,IAAV,CAAeC,QAAQ,IAAIA,QAAQ,CAACC,MAAT,CAAgBC,IAAhB,KAAyBlB,oBAApD,CAD7B;AAEQmB,QAAAA,eAFR,GAE2BL,kBAAkB,CAACG,MAAnB,CAA0BG,KAA1B,CAAgCb,GAAhC,CAAoCc,YAAY,IAAIA,YAAY,CAACC,EAAb,CAAgBpB,OAApE,CAF3B;AAIQE,QAAAA,QAJR,GAImBe,eAAe,CAACZ,GAAhB,CAAoBgB,cAAc,IAAI;AACrD,iBAAO5B,uBAAuB,CAACU,IAAxB,CAA6B,IAA7B,EAAmCkB,cAAnC,CAAP;AACD,SAFgB,CAJnB;;AAQE,YAAIV,sBAAJ,EAA4B;AAC1B;AACA;AACA;AACA;AACMW,UAAAA,mBALoB,GAKEf,SAAS,CAACM,IAAV,CAAeC,QAAQ,IAAIA,QAAQ,CAACC,MAAT,CAAgBC,IAAhB,KAAyBjB,mBAApD,CALF;AAMpBwB,UAAAA,MANoB,GAMXD,mBAAmB,CAACP,MAApB,CAA2BG,KANhB;;AAO1B,cAAIK,MAAM,IAAIA,MAAM,CAACC,MAArB,EAA6B;AAC3BtB,YAAAA,QAAQ,CAACE,IAAT,CAAcT,mBAAmB,CAACQ,IAApB,CAAyB,IAAzB,EAA+BoB,MAAM,CAAC,CAAD,CAAN,CAAUE,OAAV,CAAkBxB,SAAjD,CAAd;AACD;AACF;;AAlBH;AAAA;AAqBsB,eAAMZ,GAAG,CAACa,QAAQ,CAACG,GAAT,CAAaC,EAAE,IAAIf,IAAI,CAACe,EAAD,CAAvB,CAAD,CAAT;;AArBtB;AAqBUC,QAAAA,SArBV;AAAA;AAsBI,eAAMjB,GAAG,CAACE,YAAY,CAACkC,YAAb,CAA0BjB,OAA1B,CAAkCF,SAAlC,CAAD,CAAT;;AAtBJ;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAwBI,eAAMjB,GAAG,CAACE,YAAY,CAACkC,YAAb,CAA0BhB,OAA1B,cAAD,CAAT;;AAxBJ;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BA;;AACA;;AACA;;;AACA,OAAO,SAAUxB,iBAAV;AAAA;;AAAA;AAAA;AAAA;AAAA,aACE,IADF;AAAA;AAAA;AAAA;;AAAA;AAE0B,eAAME,IAAI,CAACI,YAAY,CAACmC,aAAb,CAA2B9B,OAA3B,CAAD,CAAV;;AAF1B;AAAA;AAEIG,QAAAA,OAFJ,eAEIA,OAFJ;AAEaC,QAAAA,SAFb,eAEaA,SAFb;AAAA;AAGH,eAAMd,IAAI,CAACH,iBAAD,EAAoBgB,OAApB,EAA6BC,SAA7B,CAAV;;AAHG;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import {fork, take, all, put, call} from 'redux-saga/effects';\nimport * as watchActions from '../actions/watch';\nimport {\n  buildVideoDetailRequest,\n  buildRelatedVideosRequest,\n  buildChannelRequest,\n  buildCommentThreadRequest\n} from '../api/youtube-api';\nimport {REQUEST} from '../actions';\nimport {SEARCH_LIST_RESPONSE, VIDEO_LIST_RESPONSE} from '../api/youtube-api-response-types';\n\nexport function* fetchWatchDetails(videoId, channelId) {\n  let requests = [\n    buildVideoDetailRequest.bind(null, videoId),\n    buildRelatedVideosRequest.bind(null, videoId),\n    buildCommentThreadRequest.bind(null, videoId)\n  ];\n\n  if (channelId) {\n    requests.push(buildChannelRequest.bind(null, channelId));\n  }\n\n  try {\n    const responses = yield all(requests.map(fn => call(fn)));\n    yield put(watchActions.details.success(responses, videoId));\n    yield call (fetchVideoDetails, responses, channelId === null);\n  } catch (error) {\n    yield put(watchActions.details.failure(error));\n  }\n}\n\nfunction* fetchVideoDetails(responses, shouldFetchChannelInfo) {\n  const searchListResponse = responses.find(response => response.result.kind === SEARCH_LIST_RESPONSE);\n  const relatedVideoIds =  searchListResponse.result.items.map(relatedVideo => relatedVideo.id.videoId);\n\n  const requests = relatedVideoIds.map(relatedVideoId => {\n    return buildVideoDetailRequest.bind(null, relatedVideoId);\n  });\n\n  if (shouldFetchChannelInfo) {\n    // we have to extract the video's channel id from the video details response\n    // so we can load additional channel information.\n    // this is only needed, when a user directly accesses .../watch?v=1234\n    // because then we only know the video id\n    const videoDetailResponse = responses.find(response => response.result.kind === VIDEO_LIST_RESPONSE);\n    const videos = videoDetailResponse.result.items;\n    if (videos && videos.length) {\n      requests.push(buildChannelRequest.bind(null, videos[0].snippet.channelId));\n    }\n  }\n\n  try {\n    const responses = yield all(requests.map(fn => call(fn)));\n    yield put(watchActions.videoDetails.success(responses));\n  } catch (error) {\n    yield put(watchActions.videoDetails.failure(error));\n  }\n}\n\n\n/******************************************************************************/\n/******************************* WATCHERS *************************************/\n/******************************************************************************/\nexport function* watchWatchDetails() {\n  while (true) {\n    const {videoId, channelId} = yield take(watchActions.WATCH_DETAILS[REQUEST]);\n    yield fork(fetchWatchDetails, videoId, channelId);\n  }\n}"]},"metadata":{},"sourceType":"module"}